# 1. JPA N+1 문제
### - N+1 문제란?
연관 관계에서 발생하는 이슈로 연간관계가 설정된 엔티티를 조회할 경우 조회된 데이터 갯수(n)만큼 연관관계의 조회 쿼리가 추가로 발생하여 데이터를 읽어오는 현상

### - 원인
- JpaRepository에 정의된 메서드를 호출하면 JPA는 메서드의 이름을 분석하여 JPQL을 생성하고 이를 실행한다.
- JPQL은 SQL을 추상화한 객체지향 쿼리 언어로서 특정 SQL에 종속되지 않은 상태에서 엔티티 객체와 필드 이름을 가지고 쿼리를 진행한다.
- DB을 읽는 메서드를 통해 JPA는 생성된 JPQL을 통해 대상이 되는 객체 정보가 담긴 Row를 조회한다.
- 그랬을 때 해당 객체가 1:N관계 또는 N:1 관계라면 JPQL은 연관관계를 무시한 상태에서 조회한다.
- 만약 조회한 객체에 연관된 Entity의 데이터가 필요한 경우 JPA는 FetchType으로 설정한 시점에 조회를 추가적으로 진행한다. 이 경우 발생하는 문제가 N+1 문제이다.

### - 해결 방법
- Fetch Join
	- 의도 : JPQL을 사용하여 DB에서 데이터를 가져올 때 처음부터 연관된 데이터까지 같이 가져는 방법(SQL에서의 Join문과 비슷하다.)
	- 이를 위해서는 JpaRepository를 구현하는 구현체에 별도의 메서드를 선언해야한다.
	- 설정 방법은 JpaRepository를 구현하는 구현체에서 별도의 메서드를 선언함과 동시에 @Query 애너테이션을 사용하여 예시 `@Query(select t from Entity t join fetch t.Field)`와 같이 "join.fetch 엔티티.연관관계_엔티티" 구문을 설정한다.
	- 이를 통해 생성된 JPQL은 inner join 구문의 형태로 DB에 전달된다.
	- 하지만 Fetcj Join을 사용하면 Entity의 연관관계에서 설정한 FetchType은 사용할 수 없게 된다.
	- Fetch Join을 통해 데이터 호출 시점에 모든 연관 관계의 데이터를 가져오기 때문에 LAZY 설정이 무의미해지고, 하나의 쿼리문으로만 데이터를 가져오기때문에 페이징 쿼리를 사용할 수 없어진다.
- @EntityGraph
	- 의도 : @EntityGraph 애너테이션의 attributePaths 옵션을 사용하여 쿼리 수행 간 바로 가져올 필드명을  지정하여 FetchType EAGER로 조회한다.
	- 설정 방법은 Fetch Join의 방법인 `@Query` 애너테이션을 사용하여 쿼리문을 작성하고 필요한 연관관계를 `@EntityGraph`에서 설정한다. 설정 방법은 아래와 같다.
	- `@EntityGraph(attributePaths = " ")`
	- 이를 통해 생성된 JPQL은 outer join 구문의 형태로 DB에 전달된다.
- Batch Size
	- 이 설정은 N+1 문제를 방지하는 방법이 아닌 N+1회 발생할 쿼리량을 1번만 더 조회하는 방식으로 성능을 최적화하는 방법이다.
	- `select * from Entity where condition_id = ?` 이 예시가 N+1 문제로 수십번, 수백번 발생한다고 가정했을 때 `select * from Entity where condition_id in (?, ?, ?)` 이와 같은 방식으로 수정하면 Entity 객체 데이터를 조회하고 N+1이 발생할 문제를 1번만 더 조회하여 2번만 조회하면 되는 방식이다.
	-  이를 위해 애플리케이션 전체에 적용이 필요한 경우 yml 또는 application.properties 파일에서 IN절에 올 수 있는 최대 인자 개수를 뜻하는 size를 설정하면 된다.
	- 또는 [[@BatchSize]] 애너테이션을 N+1 문제의 원인이 되는 Entity의 필드에 설정하는 방법도 있다. 
- @Fetch(FetchMode.SUBSELECT)
	- 한번의 쿼리로 해결하는 것이 아닌 두번의 쿼리로 해결하는 방법으로 해당 Entity를 조회하는 쿼리는 그대로 호출하고 연관관계의 데이터를 조회할 때 서브 쿼리로 조회하는 방법
	- 설정 방법은 Batch Size의 `@Batch`  애너테이션과 동일하게 N+1 문제의 원인이 되는 Entity의 필드에 `@Fetch(FetchMode.SUBSELECT)` 애너테이션을 설정한다.
	- 이를 통해 EAGER로 설정된 필드라면 조회 시점에, LAZY로 설정된 필드라면 지연 로딩된 Entity가 사용되는 시점에 서브 쿼리가 실행된다.
	- 하지만 위 방법을 사용하면 FetchType을 EAGER로 설정해야하는 단점이 있다.
- QueryBuilder
	- MyBatis, QueryDSL, JDBC Template 등 로직에 최적화하여 매뉴얼로 필요한 쿼리를 구현할 수 있다.

### - 추천되는 방법
1. 연관관계 설정이 필요하다면 FetchType을 최적화하기 어려운 EAGER보다 LAZY를 사용하고 최적화가 필요한 부분에서 Fetch Join을 사용한다.
2. Batch Size의 사이즈는 연관관계의 데이터 사이즈를 정확하게 알 수 있다면 최적화할 수 있겠지만 사실 상 연관관계의 데이터 사이즈를 알기 어렵다. 사용을 해야 한다면 1000 이하로 설정하자.
3. 만약 연관관계 설정이 필수적이지 않은 상황에서 연관관계를 설정하였고 이것이 원인이 되어 N+1 문제가 발생한다면 연관관계를 끊어버리는 것도 방법이다.


# 2. FetchType
### - EAGER
- 즉시 로딩
- 정의 : DB에 저장된 Entity 데이터를 조회할 때 해당 Entity와 연관관계가 설정된 모든 Entity가 로드되는 설정으로 ManyToOne, OneToOne 관계 설정 시의 Default 값이다.
- 대표적인 장점으로는 필요한 데이터가 한 번에 로드되기에 바로 사용 가능하다는 점과 데이터베이스에 접근하는 횟수를 줄일 수 있는 부분이 장점이다.
- 대표적인 단점으로는 연관관계가 설정된 모든 Entity가 로드되지만 모든 Entity를 필요로 하지 않다면 그만큼 메모리를 낭비하게 되고, 한번에 조회해야하는 양에 따라 성능이 저하될 수 있고 그로 인해 로딩 시간이 길어질 수 있는 부분이 단점이다.

### - LAZY
- 지연 로딩
- 정의 : DB에 저장된 Entity를 조회할 때 해당 Entity만 로드하고 연관관계가 설정된 Entity는 필요한 상황에 로드하는 설정으로 OneToMany, ManyToMany 관계 설정 시 Default 값이다.
- 대표적인 장점으로는 필요한 Entity의 데이터만 로드하기 때문에 메모리를 절약할 수 있고, 필요한 때에 필요한 Entity만 로드하기 때문에 로딩이 빠른 부분이 장점이다.
- 대표적인 단점으로는 연관된 Entity 데이터가 필요한 경우 추가적인 쿼리가 발생하여 데이터베이스에 접근하는 횟수가 증가하고 연관관계에 있는 데이터가 로드 되기 전까지 프록시, 가짜 객체가 사용되기에 복잡성이 증가한다.

### - 차이점
- 가장 큰 차이점은 로드되는 시점이다.
- EAGER는 부모 Entity가 호출되면 즉시 로딩되어 메모리에 존재하여 언제든 사용할 수 있는 상태가 되지만
- LAZY는 부모 Entity가 호출되면 부모 혼자 로딩된 상태이고 연관관계가 설정된 Entity가 필요한 경우에 해당 객체를 로드하는 사용할 수 있다.
- 한번에 전체를 로드하는 EAGER와 필요한 순간 필요한 Entity만 로드하는 LAZY는 메모리를 점유하는 부분에서도 차이점이 있다.

# 3. Transaction
### - Transaction의 개념
DBMS에서 수행되는 작업의 논리적 단위

### - Transaction의 역할
여러 데이터베이스의 연산이 하나의 트랜잭션에 묶여 처리되고, 하나의 트랜잭션에서의 모든 작업이 모두 성공적으로 완료되거나 실패한 경우 아무것도 수행되지 않은 것처럼 만들어 데이터의 일관성과 무결성을 보장한다.

### - Transaction의 특징, ACID
- 원자성(Atomicity)
	- All or Nothing
	- 트랜잭션 내의 모든 연산이 성공적으로 완료되거나, 하나라도 실패하면 모든 연산은 취소되어야 한다.
- 일관성(Consistency)
	- Keeps Data Correct
	- 트랜잭션의 작업 처리 결과는 항상 일관적이어야 하며, 그 결과가 데이터베이스의 일관성을 유지할 수 있어야한다.
- 독립성(Isolation)
	- 트랜잭션이 실행되는 동안 다른 트랜잭션의 영향을 받아서는 안된다.
	- 동시에 실행되는 트랜잭션은 서로 간섭하지 않고 독립적으로 실행되어야 한다.
- 지속성(Durability)
	- 트랜잭션이 성공적으로 완료되면 그 결과는 영구적으로 데이터베이스에 반영되어야 한다.
	- 시스템 장애가 발생하더라도 트랜잭션의 결과는 보존되어야 한다.

### - 예상 질문과 답변  
**1. 트랜잭션이란 무엇이며, 그 주요 특징은 무엇인가요?**  

- 답변
  >트랜잭션은 데이터베이스의 상태를 변화시키는 하나의 완전한 작업 단위로, 모든 작업이 성공적으로 완료되거나 실패 시에는 아무것도 수행되지 않은 것처럼 만드는 일련의 연산입니다. 주요 특징으로는 원자성(Atomicity), 일관성(Consistency), 고립성(Isolation), 지속성(Durability)의 ACID 속성이 있습니다.

**2. 트랜잭션의 ACID 속성에 대해 설명해주세요.**  (★★★★★)

- 답변
  >ACID는 트랜잭션의 네 가지 핵심 속성을 나타낸다.

- 원자성(Atomicity)
  >트랜잭션 내의 모든 연산이 성공적으로 완료되거나 하나라도 실패하면 모든 연산이 취소되어야 한다.
- 일관성(Consistency)
  >트랜잭션 완료 후 데이터베이스는 일관성 있는 상태를 유지해야 한다.
- 독립성(Isolation)
  >동시에 실행되는 트랜잭션은 서로 간섭하지 않고 독립적으로 실행되어야 한다.
- 지속성(Durability)
  >트랜잭션이 성공적으로 완료되면 그 결과는 영구적으로 데이터베이스에 반영되어야 합니다.

**3. 트랜잭션 격리 수준(isolation level)의 종류와 차이점은 무엇인가요?**  (★★★★★)

- 답변
  >트랜잭션 격리 수준에는 Read Uncommitted, Read Committed, Repeatable Read, Serializable 네 가지가 있다.
	Read Uncommitted: 다른 트랜잭션이 커밋하지 않은 변경 사항도 읽을 수 있음. (더티 리드 발생 가능)
	Read Committed: 다른 트랜잭션이 커밋한 데이터만 읽을 수 있음. (더티 리드 방지)
	Repeatable Read: 트랜잭션 동안 읽은 데이터가 변경되지 않음. (팬텀 리드 발생 가능)
	Serializable: 가장 높은 격리 수준으로, 트랜잭션을 순차적으로 실행하여 모든 문제를 방지.

**3. 트랜잭션 격리 수준 중 Read Committed와 Repeatable Read의 차이점은 무엇인가요?**  

- 답변
  >Read Committed는 트랜잭션이 커밋한 데이터만 읽을 수 있으며, 트랜잭션 중에 다른 트랜잭션이 데이터를 변경하면 읽을 수 있습니다. Repeatable Read는 트랜잭션 동안 읽은 데이터가 변경되지 않으며, 동일한 트랜잭션에서 반복적으로 같은 결과를 읽을 수 있다.

**4. 트랜잭션 격리 수준에서 발생할 수 있는 문제에는 어떤 것이 있나요?**  

- 답변
  >트랜잭션 격리 수준에 따라 더티 리드, 반복 불가능한 읽기, 팬텀 리드 문제가 발생할 수 있습니다. 더티 리드는 커밋되지 않은 데이터를 읽는 것이고, 반복 불가능한 읽기는 같은 쿼리를 두 번 실행할 때 다른 결과를 얻는 것이며, 팬텀 리드는 트랜잭션 동안 새로운 데이터가 삽입되어 쿼리 결과에 영향을 미치는 것이다.

**5. 트랜잭션의 지속성(Durability)을 보장하기 위한 방법은 무엇인가요?**  

- 답변
  >트랜잭션 로그와 데이터베이스 백업을 통해 지속성을 보장합니다. 트랜잭션 완료 후 로그를 디스크에 저장하고, 시스템 장애 발생 시 로그를 통해 복구한다.

**6. Spring에서 @Transactional 애노테이션을 사용할 때 주의할 점은 무엇인가요?**  

- 답변
  >@Transactional 애노테이션은 퍼블릭 메서드에만 적용되어야 하며, 프록시를 통해 트랜잭션이 관리되기 때문에 메서드 내부에서 다른 트랜잭션 메서드를 호출하면 트랜잭션이 제대로 적용되지 않을 수 있습니다. 또한, Propagation과 Isolation 속성을 적절히 설정해야 한다.

**7. Nested 트랜잭션과 Savepoint의 개념에 대해 설명해주세요.**  

- 답변
  >Nested 트랜잭션은 하나의 트랜잭션 내에서 또 다른 트랜잭션이 시작되는 것을 의미합니다. Savepoint는 트랜잭션 내의 특정 시점을 저장하여, 필요 시 그 시점으로 롤백할 수 있도록 하는 기능이다.

**8. 트랜잭션 롤백이 필요한 상황은 어떤 경우인가요?**  (★★★★★)

- 답변
  >트랜잭션 내의 작업 중 하나라도 실패하거나, 예외가 발생하는 경우 롤백이 필요합니다. 예를 들어, 데이터베이스 제약 조건 위반, 네트워크 오류, 비즈니스 로직 오류 등이 있다.

**9. 트랜잭션 프로파게이션(Propagation) 레벨에 대해 설명해주세요.**  

- 답변
  >트랜잭션 프로파게이션 레벨은 트랜잭션 메서드가 호출될 때 기존 트랜잭션을 유지할지, 새로운 트랜잭션을 시작할지, 또는 예외를 발생시킬지를 정의합니다. 주요 레벨로는 REQUIRED, REQUIRES_NEW, NESTED, MANDATORY, NEVER, NOT_SUPPORTED, SUPPORTS가 있다.

**10. 트랜잭션을 사용한 성능 최적화 방법은 무엇인가요?**  

- 답변
  >트랜잭션 성능 최적화를 위해 트랜잭션 범위를 최소화하고, 필요한 데이터만 조회 및 변경하며, 적절한 격리 수준을 선택하여 잠금 경쟁을 줄입니다. 또한, 배치 작업을 통해 일괄 처리하고, 캐싱을 활용하여 데이터베이스 접근을 줄일 수 있다.

**11. 트랜잭션의 프로세스는 무엇인가요?**

- 답변
> 1. Begin(시작)
>    트랜잭션이 시작된다. DBMS는 트랜잭션의 상태를 기록하고, 이후 발생하는 모든 작업을 추적한다.
> 2. Perform Operations(작업 수행)
>    트랜잭션 내에서 여러 데이터베이스 조작(SQL)이 수행된다.
> 3. Temporary Storage(임시 저장)
>    트랜잭션 내에서 수행된 모든 작업은 임시로 저장된다.
> 5. Validation(검증)
>    모든 작업이 성공
> 6. Commit
>    
> 7. Rollback

# 4. 선택 질문
### - 통합 테스트와 단위 테스트의 차이점  
- 단위 테스트(Unit Test)
	- 개념 : 소프트웨어의 개별 구성 요소나 함수, 메서드의 동작을 검증하는 테스트입니다.
	- 의미 : 코드의 작은 단위를 독립적으로 테스트하여 올바르게 작동하는지 확인합니다.
	- 역할 : 코드의 특정 부분이 예상대로 동작하는지 확인하고, 버그를 조기에 발견합니다.
	- 기능 : 빠른 피드백 제공, 특정 기능의 동작 검증, 의존성 최소화.
	- 차이점 : 단위 테스트는 외부 시스템(데이터베이스, 파일 시스템 등)과의 상호작용 없이 독립적으로 수행됩니다.

- 통합 테스트(Integration Test)
	- 개념 : 소프트웨어의 여러 구성 요소나 모듈을 함께 테스트하여 상호작용이 올바르게 이루어지는지 검증하는 테스트입니다.
	- 의미 : 시스템의 여러 부분이 통합되어 올바르게 동작하는지 확인합니다.
	- 역할 : 각 모듈 간의 상호작용과 의존성이 올바르게 동작하는지 확인하고, 시스템 전반의 기능을 검증합니다.
	- 기능 : 실제 환경에서의 동작 검증, 외부 시스템과의 상호작용 테스트, 종단 간 시나리오 검증.
	- 차이점 : 통합 테스트는 데이터베이스, 네트워크, 파일 시스템 등 외부 시스템과의 상호작용을 포함하여 수행됩니다.

### - 통합 테스트와 단위 테스트의 장/단점  
- 단위 테스트의 장점
	- 빠른 실행 : 테스트가 빠르게 실행되어 빠른 피드백을 제공합니다.
	- 간단한 디버깅 : 문제 발생 시 원인을 쉽게 파악할 수 있습니다.
	- 독립성 : 각 테스트가 독립적으로 실행되어 외부 시스템의 영향을 받지 않습니다.
	  
- 단위 테스트의 단점
	- 제한된 범위 : 시스템 전체의 동작을 검증하지 못합니다.
	- 의존성 누락 : 모듈 간의 상호작용이나 의존성 문제를 발견하지 못할 수 있습니다.

- 통합 테스트의 장점
	- 실제 환경 검증 : 실제 환경과 유사한 조건에서 시스템의 동작을 검증합니다.
	- 종단 간 시나리오 테스트 : 사용자 시나리오를 포함한 전체 시스템의 동작을 확인할 수 있습니다.
	- 의존성 테스트 : 모듈 간의 상호작용과 의존성을 검증합니다.

- 통합 테스트의 단점
	- 느린 실행 : 외부 시스템과의 상호작용으로 인해 테스트 실행 시간이 길어질 수 있습니다.
	- 복잡한 디버깅 : 문제 발생 시 원인 파악이 어렵고, 디버깅이 복잡할 수 있습니다.
	- 설정 요구 : 테스트 환경 설정이 복잡하고 시간이 많이 소요될 수 있습니다.

### - 레이어별로 나누어서 Slice Test를 하는 이유  
- 개념
  Slice Test는 애플리케이션의 특정 레이어(예: 서비스, 리포지토리, 컨트롤러)만 테스트하는 방법
  
- 이유
	- 속도 향상 : 특정 레이어만 테스트함으로써 테스트 실행 시간을 단축시킵니다.
	- 단일 책임 원칙 : 테스트의 단일 책임 원칙을 유지하여 각 레이어의 역할과 기능을 명확히 검증합니다.
	- 의존성 분리 : 레이어 간의 의존성을 분리하여, 특정 레이어의 기능만 독립적으로 테스트할 수 있습니다.
	- 디버깅 용이성 : 문제 발생 시 특정 레이어에서 쉽게 원인을 파악하고 디버깅할 수 있습니다.
	- 리소스 절약 : 불필요한 외부 시스템 접근을 피하고, 테스트 자원을 절약합니다.
	  
- 예시
	- 서비스 레이어 테스트 : 서비스 로직만 검증하고, 데이터베이스와의 상호작용은 Mock으로 대체.
	- 리포지토리 레이어 테스트 : 데이터베이스 접근 로직만 검증하고, 비즈니스 로직은 제외.

### - 테스트 코드 작성의 필요성  
- 개념
  테스트 코드는 소프트웨어 개발 과정에서 작성되는 코드로, 애플리케이션의 기능이 의도한 대로 동작하는지 검증하기 위한 목적이다.
  
- 필요성
	- 버그 예방 : 코드 변경 시 기존 기능이 깨지는 것을 방지한다.
	- 안정성 보장 : 코드의 안정성을 높이고, 신뢰성을 보장한.
	- 문서화 : 테스트 코드는 코드의 기능과 사용 방법을 설명하는 문서 역할을 한다.
	- 리팩토링 지원 : 코드 리팩토링 시 테스트를 통해 기능이 유지되는지 확인할 수 있다.
	- 신속한 피드백 : 코드 변경 후 빠른 피드백을 제공하여 개발 속도를 향상시킨다.
	- 자동화 : CI/CD 파이프라인에서 자동화된 테스트를 통해 지속적인 통합을 지원한다.
	  
- 느낀 점
	- 안심감 : 테스트 코드가 있으면 코드 변경 후에도 기능이 제대로 동작하는지 쉽게 확인할 수 있어 안심이 됩니다.
	- 생산성 향상 : 테스트 코드 작성으로 초기 개발 시간은 늘어날 수 있지만, 이후 버그 수정과 리팩토링 시 시간을 절약할 수 있어 전체 개발 생산성이 향상됩니다.
	- 문서 역할 : 테스트 코드는 기능에 대한 명확한 설명을 제공하여, 유지보수 시 유용한 참조 자료가 됩니다.

### - JPA와 Hibernate의 차이점  
- JPA (Java Persistence API)
	- 개념 : JPA는 자바 표준 ORM(Object-Relational Mapping) 프레임워크입니다. 자바 객체를 관계형 데이터베이스의 테이블에 매핑하기 위한 API입니다.
	- 역할 : 표준 인터페이스를 제공하여 다양한 ORM 구현체(Hibernate, EclipseLink 등)를 사용할 수 있도록 합니다.
	- 기능 : 데이터베이스 독립적 프로그래밍, 애노테이션 또는 XML 설정, 객체-관계 매핑, 엔티티 관리 등.

- Hibernate
	- 개념 : Hibernate는 JPA의 구현체 중 하나로, 강력하고 유연한 ORM 프레임워크입니다.
	- 역할 : JPA 표준을 구현하면서도, 자체 확장 기능을 제공합니다.
	- 기능 : 캐싱, 엔티티 매핑, 쿼리 언어(HQL), 데이터베이스 벤더 확장 기능 등.

- 차이점:  
	- 표준과 구현체 : JPA는 자바 표준 API이고, Hibernate는 그 표준을 구현한 라이브러리입니다.
	- 확장 기능 : Hibernate는 JPA 표준 외에도 자체적인 다양한 확장 기능을 제공합니다.
	- 사용 방법 : JPA 인터페이스를 사용하면 특정 구현체(Hibernate 등)에 종속되지 않지만, Hibernate의 고유 기능을 사용하면 Hibernate에 종속될 수 있습니다.