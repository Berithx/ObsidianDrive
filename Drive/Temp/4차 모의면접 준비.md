# 1. 사용자가 API 요청에 대한 응답을 할 때 Spring 내부 동작에 대해 설명할 수 있는가?
## - 개념
### - 기본 동작 원리
> - Client의 API 요청이 서버에 도달하였을 때 DispatcherServlet이 해당 요청을 수신하고 해당 요청을 어떤 컨트롤러로 전달을 해줘야하는지 Handler Mapping에서 해당 정보를 확인합니다.
> - Handler Mapping에서 확인된 컨트롤러의 정보를 활용하여 Hanlder Adapter를 통해 Client의 API요청을 처리할 수 있는 컨트롤러를 호출합니다.
> - HandlerAdapter가 특정 Controller의 메서드를 호출하고 불려지는 그 사이에 Handler Interceptor가 있으며 이 위치에서 Controller의 호출 전, 후로 요청과 응답의 결과를 가공할 수 있습니다.
> - 위 과정을 통해 클라이언트의 API  요청을 받은  Controller는 해당 메서드 내부에 구현된 비즈니스 로직에 따라 동작을 하고 그 결과를 진입한 경로의 역순으로 진행되어 Client에게 전달됩니다.
> - 이 과정 중 View를 반환하는 경우 DistpatcherServlet은 View Resolver에게 Cotroller에서 응답한 View 정보를 전달하고 이 정보를 기반으로 JSP, Thymeleaf와 같은 템플릿 엔진으로 변환하고 해당 템플릿을 활용하여 Controller에서 응답한 정보를 렌더링하여 Client에 반환합니다.
> - 반대로 View가 아닌 값을 반환하면 ViewResolver가 아닌 HttpMessageConverter를 통해 HTTP Response 본문으로 직렬화하여 반환합니다.

### - 예상질문
1. DispatcherServlet의 역할 및 초기화 과정은 무엇인가?
   > **역할**
   >   
   > DispatcherServlet은 Spring MVC의 프론트 컨트롤러로서 모든 HTTP 요청을 중앙에서 처리하는 역할을 수행합니다. Client가 요청을 보내면 이 요청을 어떤 이름으로 Mapping된 컨트롤러에 전달해야하는지 확인하고 Handler Adapter에게 해당 정보를 전달하여 통해 해당 컨트롤러의 메서드를 호출하도록합니다.
   > 
   > **초기화 과정**
   > 
   > 서버 기동 간 Dispatcher를 등록하고, 자체적인 어플리케이션 컨텍스트를 초기화합니다.
   > 이 초기화 과정에서 설정 파일이나 클래스가 로드됩니다.
   > 이후 요청을 처리할 Handler Mapping과 Handler Adapter를 로드하는 것으로 요청을 받은 준비가 됩니다.
   
2. HandlerMapping이 여러 개일 경우 우선순위는 무엇으로 결정되는가?
   > Spring MVC에서 Handler Mapping이 여러 개 등록된 경우 우선순위는 `@Order` 애너테이션을 사용하거나 Ordered 인터페이스를 구현하는 것으로 정의할 수 있습니다.
   
3. HandlerAdapter가 하는 역할은 무엇인가?
   > DispatcheServlet이  핸들러를 실행할 때 사용하는 어댑터입니다. 실행되는 핸들러마다 서로 다른 방법으로 요청을 처리할 수 있기 때문에 DispatcherServlet은 직접적으로 호출하지 않고 Handler Adapter를 통해 핸들러를 실행합니다.
   
4. 비동기 요청을 처리하는 방법은?
   > Spring에서 비동기 요청은 `@Async`, `DeferredResult`, `Callable`, `CompletableFuture` 등을 통해 처리할 수 있습니다. `@Async`는 메소드를 비동기적으로 실행하게 하고 메인 스레드는 이를 기다리지 않고 바로 응답을 반환할 수 있습니다. `DeferredResult`, `Callable`은 요청을 비동기적으로 처리하고 처리 결과가 준비되면 Client에 응답을 반환합니다. `CompletableFuture`는 비동기 작업을 완료할 때 결과를 반환할 수 있는 방식입니다.
   
5. ViewResolver의 역할과 다양한 종류에 대해 설명하라
   > Controller가 반환하는 논리적인 뷰 이름을 실제 뷰 객체로 변환하는 역할을 수행합니다.
   > 예를 들어 특정 뷰 이름을 반환하면 ViewResolver는 이것을 해당 특정 이름을 가진 JSP, HTML과 같은 실제 템플릿 파일로 매핑합니다. 이 때 사용되는 ViewResolver는 사용하는 라이브러리에 따라 다르게 적용됩니다.
   
6. ModelAndView 객체의 역할과 사용 방법은 무엇인가?
   > ModelAndView 객체는 Spring MVC에서 Model 데이터와 View 이름을 함께 전달할 때 사용하는 객체입니다. 이 객체는 뷰에 전달할 데이터와 이 데이터가 표시될 뷰 이름을 함께 저장하여 반환되며 이를 통해 DistpatcherServlet으로 전달할 뷰 이름과 데이터를 쉽게 관리할 수 있습니다.
   
7. 예외 처리 방식은 무엇인가?
   > 예외처리는 주로 `@ExceptionHandler`를 통한 특정 예외가 발생한 상황에 대해 특정 컨트롤러 또는 컨트롤러의 메서드 수준에서의 핸들링, `@ControllerAdvice` / `@RestControllerAdvice`를 통한 모든 컨트롤러에 전역적으로 적용하여 특정 예외를 포착하여 중앙에서 처리하는 핸들링, `HandlerExceptionResolver`를 통한 전체 어플리케이션 수준에서 모든 요청과 모든 예외에 대한 글로벌 예외 처리 핸들링이 있습니다.
   
8. `@ResponseBody`의 역할과 사용 사례는 무엇인가?
   > 컨트롤러 메서드가 반환하는 값을 HTTP Response 본문으로 직접 반환하도록 하는 애너테이션입니다. 주로 JSON, XML 데이터를 반환하는데 사용되며 이 애너테이션이 적용된 메서드의 반환 값은 `HttpMessageConverter`를 통해 직렬화되어 Client로 반환됩니다.
   
9. JSON 응답을 생성할 때 `HttpMessageConverter`가 하는 역할은 무엇인가?
   > 컨트롤러 메서드에서 반환된 객체를 Http Request 또는 Response의 본문으로 변환하는 역할을 수행합니다. Spring은 필요에 따라 `MappingJackson2HttpMessageConverter` 등의 다양한 `HttpMessageConverter`를 제공하고 이것을 통해 XML, 텍스트, 바이너리 데이터 등의 형태로 응답을 처리할 수 있습니다.
   
10. Request가 Filter와 Interceptor를 거치는 과정은 무엇인가?
    > Spring MVC에서 요청이 들어오면 Filter Chain를 통과하게 됩니다. Filter는 Servlet Spec의 일로 요청과 응답에 대해 전처리 및 후처리 작업을 수행합니다. Filter를 통과하면 DispatcherServlet에 요청이 도착하고 Handler Mapping, Handler Adapter 과정을 거치는데Handler Apapter가 특정 컨트롤러를 호출하는 과정 사이에서 Interceptor가 컨트롤러에 요청하기 전의 전처리, 요청이 완료된 이후의 후처리 등을 수행할 수 있습니다. Filter는 Servlet 레벨에서 동작하고 Interceptor는 Spring MVC 내부에서 동작합니다.
# 2. Spring AOP는 무엇인가?
## - 개념
### - 기본 개념
> - AOP는 Aspect Oriented Programing, 관점 지향 프로그래밍을 뜻하는 것으로 다른 서비스의 비즈니스 로직과 연관되는 횡단 관심사들을 모듈화하여 비즈니스 로직을 비즈니스 로직이 더 비즈니스 로직다워질 수 있도록 하는 프로그래밍 패러다임입니다.
> - AOP를 통해 여러 비즈니스 로직에서 공통적으로 적용될 수 있는 로깅, 트랜잭션 관리, 보안 등의 비즈니스 로직의 핵심 기능외 부가적인 기능들을 비즈니스 로직에서 분리하여 모듈화하는 것으로 중복 코드를 줄이고 차후 부가적인 기능에 대한 유지보수에 있어 이점을 가질 수 있습니다.
> - AOP는  `@Before`, `@After`, `@Around` 등의 애너테이션을 통해 어느 시점에 부가기능을 적용할지 선택할 수 있으며, `PointCut`을 정의하여 적용하는 것으로 어떤 레벨의 비즈니스 로직에 AOP를 적용할지 선택할 수 있습니다.

### - 예상 질문
1. Spring AOP와 Proxy 패턴의 차이점은 무엇인가?
   > Spring AOP와 Proxy 패턴 모두 객체의 메소드 호출을 가로채어 부가적인 기능을 추가하는데 사용됩니다. 하지만 주된 차이점은 Spring AOP는 로깅, 보안 등의 특정 횡단 관심사를 모듈화하여 여러 객체에 적용할 수 있는 반면에 Proxy 패턴은 특정 객체의 동작을 감싸서 확장하는데 중점을 둡니다. Proxy 패턴은 주로 개별 객체의 동작을 제어하기 위해 사용되자만 Spring AOP는 어플리케이션 전반에 걸쳐 반복되는 관심사를 분리하고 재사용성을 높이기 위해 사용됩니다.
   
2. Spring AOP에서 `Aspect`와 `Advice`의 차이점은 무엇인가
   > `Aspect`는 횡단 관심사를 모듈화한 단위로 공통 기능을 정의하는데 사용합니다. 하지만 `Advice`는 `Aspect` 내부에서 실제로 수행되는 코드로 특정 시점에 실행됩니다. `Aspect`는 여러 개의 `Advice`를 포함할 수 있으며 각 `Advice`는 특정 시점에 적용되어 필요한 작업을 수행합니다.
   
3. AOP에서 `Pointcut`이란 무엇이고 구체적으로 어떻게 정의되는가?
   > `Pointcut`은 `Advice`가 적용될 위치를 정의하는 표현식입니다. 이것을 통하여 특정 메소드, 클래스 , 패키지에 `Advice`를 적용할 수 있습니다. `Pointcut` 표현식은 메소드 이름, 클래스 이름, 애너테이션을 기반으로 정의할 수 있고 Spring에서는 `execution`, `within`, `@annotation` 과 같은 표현식을 사용합니다.
   
4. Spring AOP와 AspectJ의 차이점은 무엇인가?
   > Spring AOP는 런타임에 Proxy 객체를 생성하여 AOP 기능을 제공하는 프레임워크 기반의 AOP입니다. 주로 메서드 레벨에서 AOP를 적용하고 Proxy 기반이기에 성능과 유연성 측면에서 제한이 있습니다. 이에 반해 AspectJ는 컴파일 시점, 클래스 로드 시점, 런타임 시점에 `Aspect`를 적용할 수 있는 더 강력한 AOP 프레임워크입니다. `AspectJ`는 코드 삽입을 통해 AOP를 구현하므로 더 강력하고 유연한 기능을 제공하지만, 설정과 사용이 더 복잡할 수 있습니다.
   
5. Spring AOP에서 `JoinPoint`와 `ProceedingJoinPoint`의 차이점은 무엇인가?
   > `JointPoint`는 AOP에서 `Advice`가 적용될 수 있는 지점을 나타내며 메소드 호출, 필드 접근 등의 구체적인 시점을 포함합니다. `JoinPoint`는 현재 실행 중인 메소드의 메타정보를 제공할 수 있습니다. 하지만 `ProceedingJoinPoint`는 `@Around`가 설정된 `Advice`에서 사용되고 메소드 실행를 제어할 수 있는 기능을 제공합니다. `ProceedingJoinPoint`는 메소드를 실행하거나 실행하지 않도록 할 수 있고 메소드 실행 전후에 추가적인 작업을 수행할 수 있습니다.
   
6. AOP의 `Weaving` 과정은 무엇이고 Spring AOP에서 `Weaving`이 어떻게 이뤄지는가?
   > `Weaving`은 `Aspect`를 실제 코드에 적용하는 과정을 의미합니다. `Weaving`은 컴파일 시점, 클래스 로드 시점, 런타임 시점에서 발생할 수 있습니다. Spring AOP는 주로 런타임 시점에 Proxy 객체를 생성하여 Weaving을 수행합니다. 이것을 통해 메소드 호출 시에만 AOP 기능을 적용하고 Proxy를 통해 추가적인 기능을 메소드 실행 전후에 삽입합니다.
   
7. Spring AOP가 횡단 관심사를 처리하는데 있어 어떤 이점을 제공하는가?
   > Spring AOP는 횡단 관심사를 분리하여 코드 중복을 줄이고, 비즈니스 로직과 공통 기능을 분리하는 것으로 유지보수성을 높입니다. 로깅, 보안과 같은 기능을 중앙에서 관리할 수 있으며 특정 기능을 전역으로 쉽게 적용할 수 있습니다.
   
8. Spring AOP의 Proxy 기반 접근 방식에서 AOP가 적용되지 않는 메소드나 상황이 있는가?
   > Spring AOP는 기본적으로 Proxy 기반이기 때문에 `final`가 적용된 클래스나 메소드에 적용되지 않습니다. 또한 `private` 메소드나 `static` 메소드에도 AOP가 적용되지 않습니다. 이런 제한점은 Proxy 객체가 런타임에 메소드를 오버라이드할 수 없기 때문입니다.
   
9. Spring AOP에서 성능 오버헤드가 발생할 가능성이 있는가? 있다면 어떤 상황인가?
   > Spring AOP는 런타임 시점에 Proxy 객체를 생성하여 메소드 호출을 가로채기 때문에 Proxy 생성과 메소드 호출 시점에 성능 오버헤드가 발생할 수 있습니다. 매우 빈번하게 호출되는 메소드나 대규모 어플리케이션에서 많은 Proxy 객체가 생성될 경우 성능에 영향을 끼칠 수 있습니다.
   
10. Spring AOP를 사용하여 트랜잭션 관리와 로깅을 동시에 처리하려면 어떻게 해야하는가?
    >트랜잭션과 로킹을 동시에 처리하기 위해 각각의 `Aspect`를 정의하고 `Pointcut` 표현식을 통해 동일한 `Pointcut`에 대해 여러 `Advice`를 적용할 수 있습니다. 트랜잭션 Aspect와 로깅 Aspect를 각각 정의하고 동일한 메소드에 이 Aspect를 적용하면 해당 메소드 호출 시 두 가지의 AOP가 동시에 처리됩니다.

# 3. Transaction 전파 전략을 설명하고 각각 어떤 상황에서 사용되는가?
## - 개념
### - 기본 개념
> - Spring의 트랜잭션 전파, propagation 전략은 메소드가 트랜잭션 컨텍스트에서 호출될 때 그 메소드가 어떻게 트랜잭션을 처리할지 결정하는 방식을 뜻합니다. 각기 다른 전파 옵션을 통해 메소드가 기존 트랜잭션을 사용할지, 새로운 트랜잭션을 생성할지, 트랜잭션 없지 실행할지를 정의할 수 있습니다. 이 정의에는 7가지의 전파 옵션이 있습니다.
> - **REQUIRED**
> 	  - 기본 전파 옵션으로 현재 트랜잭션이 존재하면 해당 트랜잭션을 사용하고 존재하지 않으면 새로운 트랜잭션을 시작합니다.
> 	  - 사례 : 대부분의 비즈니스 메소드에서 사용합니다. 메소드가 호출될 때 이미 트랜잭션이 존재하면 해당 트랜잭션 내에서 실행하고 그렇지 않으면 새로운 트랜잭션을 시작하여 트랜잭션 관리를 간편하게 하고 트랜잭션 간의 일관성을 유지합니다.
>   - **REQUIRES_NEW**
> 	  - 항상 새로운 트랜잭션을 시작하며, 기존 트랜잭션이 존재하면 이것을 일시 중지합니다.
> 	  - 사례 : 독립적인 트랜잭션이 필요할 때 사용됩니다. 메인 트랜잭션이 성공하거나 실패해도 특정 로직은 별로도 실행되어야 할 때 사용합니다.
>   - **NESTED**
> 	  - 현재 트랜잭션이 존재하면 중첩된 트랜잭션이 시작하고, 그렇지 않으면 새로운 트랜잭션을 시작합니다. 중첩된 트랜잭션은 부모 트랜잭션의 일부로 간주됩니다.
> 	  - 부모 트랜잭션의 롤백이 자식 트랜잭션에도 영향을 미쳐야하는 경우 사용합니다. 여러 단계로 이루어진 복합적인 작업에서 일부 단계만 롤백하고 전체 트랜잭션은 유지해야 할 때 사용할 수 있습니다.
>   - **MANDATORY**
> 	  - 현재 트랜잭션이 존재해야 합니다. 존재하지 않으면 예외가 발생합니다.
> 	  - 사례 : 메소드가 항상 트랜잭션 내에서 실행되어야 하고, 트랜잭션 없이 실행되어서는 안될 때 사용합니다. 주로 상위 계층에서 트랜잭션을 관리해야하는 상황에서 하위 메소드가 트랜잭션 없이 실행되지 않도록 강제할 때 사용할 수 있습니다.
>   - **NEVER**
> 	  - 트랜잭션이 존재하지 않아야 합니다. 현재 트랜잭션이 존재하면 예외가 발생합니다.
> 	  - 사례 : 트랜잭션 컨텍스트 없이 실행되어야 하는 메소드에 사용됩니다. 읽기 전용 메소드나 트랜잭션을 사용하면 안되는 작업에서 사용할 수 있습니다.
>   - **SUPPORTS**
> 	  - 트랜잭션이 존재하면 이를 사용하고, 존재하지 않으면 트랜잭션 없이 실행됩니다.
> 	  - 사례 : 트랜잭션의 존재 여부가 중요하지 않은 비즈니스 로직에서 사용합니다. 이는 트랜잭션에 강하게 의존하지 않으며 단순 조회 기능 등에 사용할 수 있습니다.
>   - **NOT_SUPPORTED**
> 	  - 현재 트랜잭션이 존재하면 이를 일시 중지하고 트랜잭션 없이 메소드를 실행합니다.
> 	  - 사례 : 트랜잭션 내에서 실행되면 안되는 작업에서 사용합니다. 트랜잭션에 의해 제어될 필요가 없는 외부 시스템과의 통신, 파일 시스템 작업 등에 사용할 수 있습니다.

### - 예상 질문
1. 트랜잭션 전파 중 `REQUIRES_NEW`와 `NESTED`의 차이점은 무엇인가?
   > 질문의 두 트랜잭션 모두 새로운 트랜잭션을 시작하지만 동작 방식이 다릅니다. `REQUIRED_NEW`는 항상 새로운 트랜잭션을 시작하고 기존 트랜잭션이 존재하면 이를 일시 중지합니다. 이를 통해 `REQUIRED_NEW`를 통해 시작된 트랜잭션은 독립적으로 커밋 또는 롤백되고 부모 트랜잭션의 영향을 받지 않습니다. 하지만 `NESTED`는 현재 트랜잭션이 존재하면 중첩된 트랜잭션을 시작합니다. 이 중첩된 트랜잭션은 부모 트랜잭션의 일부로 간주되고 부모 트랜잭션이 커밋
   
2. `MANDATORY`와 `REQUIRED`의 차이점은 무엇인가?
   
3. Spring에서 트랜잭션 전파 전략을 설정할 때, 메소드 내에서 예외가 발생하면 트랜잭션이 어떻게 처리되는가?
   
4. `SUPPORTS`와 `NOT_SUPPORTED`의 차이점은 무엇인가?
   
5. Spring에서 트랜잭션 격리 수준과 전파 설정 간의 관계는 무엇인가?
   
6. 트랜잭션 전파 전략 중 `NEVER`는 언제 사용해야하는가?
   
7. 트랜잭션 전파 전략이 데이터베이스에서 실제로 어떻게 구현되는지 설명할 수 있는가?
   
8. `REQUIRED` 전파 전략을 사용할 때 메인 트랜잭션이 롤백되면 하위 트랜잭션은 어떻게 처리되는가?
   
9. Spring에서 트랜잭션 전파 전략을 다르게 설정해야 할 필요성이 발생하는 시나리오는 어떤 것이 있는가?
   
10. Spring에서 트랜잭션 전파 전략을 설정을 설정하지 않으면 기본적으로 어떤 전략이 적용되는가? 그 이유는 무엇인가?