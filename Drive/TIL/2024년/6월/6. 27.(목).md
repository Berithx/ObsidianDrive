```table-of-contents
title: 
style: nestedList # TOC style (nestedList|inlineFirstLevel)
minLevel: 0 # Include headings from the specified level
maxLevel: 0 # Include headings up to the specified level
includeLinks: true # Make headings clickable
debugInConsole: false # Print debug info in Obsidian console
```

# 1. Spring
## ■ JPA N+1 문제

### - N+1 문제란?
연관 관계에서 발생하는 이슈로 연간관계가 설정된 엔티티를 조회할 경우 조회된 데이터 갯수(n)만큼 연관관계의 조회 쿼리가 추가로 발생하여 데이터를 읽어오는 현상

### - 원인
- JpaRepository에 정의된 메서드를 호출하면 JPA는 메서드의 이름을 분석하여 JPQL을 생성하고 이를 실행한다.
- JPQL은 SQL을 추상화한 객체지향 쿼리 언어로서 특정 SQL에 종속되지 않은 상태에서 엔티티 객체와 필드 이름을 가지고 쿼리를 진행한다.
- DB을 읽는 메서드를 통해 JPA는 생성된 JPQL을 통해 대상이 되는 객체 정보가 담긴 Row를 조회한다.
- 그랬을 때 해당 객체가 1:N관계 또는 N:1 관계라면 JPQL은 연관관계를 무시한 상태에서 조회한다.
- 만약 조회한 객체에 연관된 Entity의 데이터가 필요한 경우 JPA는 FetchType으로 설정한 시점에 조회를 추가적으로 진행한다. 이 경우 발생하는 문제가 N+1 문제이다.

### - 해결 방법
- Fetch Join
	- 의도 : JPQL을 사용하여 DB에서 데이터를 가져올 때 처음부터 연관된 데이터까지 같이 가져는 방법(SQL에서의 Join문과 비슷하다.)
	- 이를 위해서는 JpaRepository를 구현하는 구현체에 별도의 메서드를 선언해야한다.
	- 선언 방법은 JpaRepository를 구현하는 구현체에서 별도의 메서드를 선언함과 동시에 `@Query` 애너테이션을 사용하여 예시 `@Query(select t from Entity t join fetch t.Field)`와 같이 "join.fetch 엔티티.연관관계_엔티티" 구문을 설정한다.
	- 이를 통해 생성된 JPQL은 inner join 구문의 형태로 DB에 전달된다.
	- 하지만 Fetcj Join을 사용하면 Entity의 연관관계에서 설정한 FetchType은 사용할 수 없게 된다.
	- Fetch Join을 통해 데이터 호출 시점에 모든 연관 관계의 데이터를 가져오기 때문에 LAZY 설정이 무의미해지고, 하나의 쿼리문으로만 데이터를 가져오기때문에 페이징 쿼리를 사용할 수 없어진다.
- @EntityGraph
	- 의도 : @EntityGraph 애너테이션의 attributePaths 옵션을 사용하여 쿼리 수행 간 바로 가져올 필드명을  지정하여 FetchType EAGER로 조회한다.
	- Fetch Join의 방법인 `@Query` 애너테이션을 사용하여 
	- `@EntityGraph(attributePaths = " ")`
- Batch Size
- @Fetch(FetchMode.SUBSELECT)




[[Templates]]
