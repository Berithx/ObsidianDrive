```table-of-contents
title: 
style: nestedList # TOC style (nestedList|inlineFirstLevel)
minLevel: 0 # Include headings from the specified level
maxLevel: 0 # Include headings up to the specified level
includeLinks: true # Make headings clickable
debugInConsole: false # Print debug info in Obsidian console
```

# 1. Spring
## ■ IoC Containner와 Bean

### - Spring IoC Container
- DI(주입)을 사용하기 위해서는 객체 생성이 우선되어야 한다.
- 하지만 우리는 언제, 어디서, 누가 객체 생성을 해야하는지 모른다.
- DI를 사용하기 위한 객체는 Spring Framwork가 필요한 객체를 생성하고 관리하는 역할을 대신 해준다.

- Bean : Spring이 관리하는 객체
- Spring IoC Container : Bean들을 모아둔 컨테이너

### - Spring Bean 등록 방법
- @Component 애너테이션
	- Bean으로 등록하고자 하는 클래스 위에 설정한다.
	  ``` java
		@Component
		public class Service { ... }
		```
	- Spring 서버가 작동을 시작할 때 IoC Container에 Bean을 저장한다.
	  ```java
		// 1. MemoService 객체 생성
		Service Service = new Service();

		// 2. Spring IoC 컨테이너에 Bean (Service) 저장
		// Service -> Spring IoC 컨테이너
		```
	- Bean 아이콘을 통해서 Spring IoC Container에 의해 관리되고 있는 클래스라는 것을 확인할 수 있다.

- @ComponentScan
	- Spring 서버가 작동을 시작할 때 @ComponentScan에 설정해둔 Package 위치와 하위 package를 전부 확인하고 @Component가 설정된 클래스들을 Bean으로 등록한다.
	  ``` java
		@Configuration
		@ComponentScan(basePackages = "com.domain.service")
		class BeanConfig { ... }
		```
		
	- @SpringBootApplication에 의해 default 설정되어있다.
	  ![[Pasted image 20240523201956.png]]

### - Spring Bean 사용 방법
- @Autowired
	- 필드 위에 적용
	  ``` java
		@Component
		public class Service {
		
	    @Autowired
	    private Repository Repository;
		
		// ...
		}
		```
		- Spring IoC Container에 저장된 Repository Bean을 해당 필드에 DI한다.
	
	  - Bean을 주입할 때 사용할 메서드 위에 적용
	    ``` java
	    @Component
		public class Service {

		    private final Repository Repository;

		    @Autowired
			public Service(Repository Repository) {
		        this.Repository = Repository;
		    }
		
		// ...
		}
		```
		- 객체의 불변성을 확보할 수 있고 일반적으로 생성자를 통해 DI하는 것이 좋다.
		- Set 메서드를 통해 DI 할 수도 있다.
	  
	  - @Autowired 적용 조건
		- Spring IoC Container에 의해 관리되는 클래스에서만 가능하다.
		- Spring IoC Container  





[[Templates]]
