```table-of-contents
title: 
style: nestedList # TOC style (nestedList|inlineFirstLevel)
minLevel: 0 # Include headings from the specified level
maxLevel: 0 # Include headings up to the specified level
includeLinks: true # Make headings clickable
debugInConsole: false # Print debug info in Obsidian console
```

# 1. Spring
## ■ Spring Data JPA

### - Spring Data JPA란?

![[Pasted image 20240528192518.png]]
- Spring Data JPA : JPA를 쉽게 사용할 수 있게 만들어놓은 하나의 모듈
	- JPA를 추상화시킨 Repository 인터페이스를 제공한다.
- Repository 인터페이스는 Hibernate와 같은 JPA 구현체를 사용하여 구현한 클래스를 통해 사용된다.

### - Spring Data JPA와 SimpleJpaRepository
![[Pasted image 20240528192709.png]]
- Spring Data JPA에서는 JpaRepository 인터페이스를 구현하는 클래스를 자동으로 생성한다.
	- Spring 서버가 작동될 때 JpaRepository 인터페이스를 상속받은 인터페이스가 자동으로 스캔되면 해당 인터페이스의 정보를 토대로 SimpleJpaRepository 클래스를 생성해주고, 이 클래스를 Bean으로 등록한다.
- 인터페이스의 구현 클래스를 직접 작성하지 않아도 JpaRepository 인터페이스를 통해 JPA의 기능을 사용할 수 있다.

### - Spring Data JPA 사용방법
- **등록**
  ``` java
	public interface EntityRepository extends JpaRepository<Entity, Long> {
		// SimpleRepository에서 제공하는 메서드 외 필요한 메서드를 구현
	}
	```
	-  `JpaRepository<"@Entity 클래스", "@Id의 데이터 타입">`을 상속받는 인터페이스로 선언
		- Spring Data JPA에 의해 자동으로 Bean으로 등록된다.
		- 제네릭스의 `@Entity 클래스` 위치에 DB와 연계하여 영속성 컨텍스트 관리가 필요한 Entity를 추가하고, 해당 객체의 `@Id` 데이터 타입을 입력하면 `EntityRepository`는 DB의 entity 테이블과 연결되어 CRUD 작업을 처리하는 인터페이스가 된다.
		  
- **save**
  ``` java
	public EntityResponseDto createEntity(EntityRequestDto requestDto) {
    // RequestDto -> Entity
    Entity entity = new Entity(requestDto);

    // DB 저장
    Entity saveEntity = memoRepository.save(entity);

    // Entity -> ResponseDto
    EntityResponseDto entityResponseDto = new EntityResponseDto(saveEntity);

    return entityResponseDto;
}
	```

	![[Pasted image 20240528193831.png]]
	- SimpleJpaRepository의 save 메서드를 확인해보면 영속성 컨텍스트에 entity를 저장하는 코드가 있다.
	- save 메서드를 사용해 객체를 저장할 수 있다.
		- 파라미터로 저장하려는 entity 객체를 입력한다.
		- save 메서드에는 @Transactional 애너테이션이 적용되어 있다.
		  
- **findAll**
  ``` java
	public List<EntityResponseDto> getEntitys() {
    // DB 조회
    return entityRepository.findAll().stream().map(EntityResponseDto::new).toList();
	}
	```
	
	![[Pasted image 20240528194258.png]]
	- findAll 메서드를 사용해 테이블 전체 데이터를 조회할 수 있다.
	  
- **findById**
  ``` java
	private Entity findEntity(Long id) {
	    return entityRepository.findById(id).orElseThrow(() ->
            new IllegalArgumentException("선택한 객체가 존재하지 않습니다.")
    );
	}
	```
	
	![[Pasted image 20240528194707.png]]
	- SimpleJpaRepository의 findById 메서드를 확인해보면 반환 타입이 Optional이다.
		- 파라미터로 찾고자하는 Entity의 id 값을 입력한다.
	- Optional<Entity 타입>을 반환 타입으로 받고 추가적으로 null 체크를 하거나
	- `orElseThrow` 등을 사용하여 반환 값에 따라 예외를 던지도록 처리할 수 있다.
	  
- **update**
  ``` java
	@Transactional
	public Long updateEntity(Long id, EntityRequestDto requestDto) {
	    // 해당 객체가 DB에 존재하는지 확인
	    Entity entity = findEntity(id);

	    // entity 내용 수정
	    entity.update(requestDto);

	    return id;
	}
	```
	- SimpleJpaRepository에 Update 메서드는 존재하지 않는다.
	- 위 코드처럼 영속성 컨텍스트의 변경 감지(Dirty Checking)을 통해 update를 할 수 있고,
	  변경 감지를 적용하기 위해 메서드에 @Transactional 적용이 필요하다.
	
- **delete**
	- 




























[[5월]]
