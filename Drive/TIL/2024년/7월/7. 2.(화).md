```table-of-contents
title: 
style: nestedList # TOC style (nestedList|inlineFirstLevel)
minLevel: 0 # Include headings from the specified level
maxLevel: 0 # Include headings up to the specified level
includeLinks: true # Make headings clickable
debugInConsole: false # Print debug info in Obsidian console
```

# 1. Spring
## ■ QueryDSL

### - QueryDSL이란
- 정적 타입을 이용하여 SQL과 같은 쿼리를 하드코딩하는 것이 아닌 코드 형태로 생성할 수 있도록 해주는 오픈소스 빌더 API

### - JPQL과 QueryDSL의 차이
- JPQL
  JPA Repository에 Custom function에 `@Query` 애너테이션을 통해 쿼리문을 작성하는 방법
  ``` java
	public interface PersonRepository extends JpaRepository<Person, Long>{
	
	/*	변수 바인딩 시, ?시퀀스 사용하는 경우 */
	@Query("select p from Person p where p.firstName = ?1 and p.lastName = ?2")
	Person findPerson(String firstName, String lastName);
	
	/*	변수 바인딩 시, :이름 사용하는 경우 */
	@Query("select p from Person p where p.firstName = :firstName and p.lastName = :lastName")
	Person findPerson2(@Param("firstName") String firstName, @Param("lastName") String lastName);
	}
	```
	- `@Query`의 Query문을 확인해보면
		- Person Entity의 스펙(필드 등)이 변경되는 경우
			- 만약 "firstName" 필드명이 "fName"으로 변경되었을 때 Query문의 조건이 변경된 것은 아니기 때문에 의도적으로 확인하지 않으면 Compile 과정에서 식별되지 않고 Runtime 과정에서 해당 API가 호출될 때 에러가 발생하는 것으로 식별된다.
			- 
			  
- QueryDSL
  JPQL과 같이 Query문을 문자열로 작성하여 Compile 과정에서 Type-Check 되지 않던 문제를 해결하기 위해 나온 프레임워크
  ``` java
	@PersistenceContext
	EntityManager em;
	
	public List<Person> selectPersonByNm(String firstNm, String lastNm){
		JPAQueryFactory jqf = new JPAQueryFactory(em);
		QPerson person = QPerson.person;
	
		List<Person> personList = jpf
							.selectFrom(person)
							.where(person.firstName.eq(firstNm)
								.and(person.lastName.eq(lastNm))
							.fetch();
	
		return personList;
	}
	```
	- Query문이 문자열이 아닌 함수 형태로 조합되어 최종 결과를 반환한다.
	- JPA Entity와 연동되어 조회 시 영속성 컨텍스트를 참조한다.
	- 위의 JPQL 의 예시 상황이라면
		- 



[[Templates]]
